// Copyright 2021 the Parley Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! Boundary analysis.

use icu_segmenter::{GraphemeClusterSegmenter, LineSegmenter, WordSegmenter};

/// The content type of a cluster.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
#[repr(u8)]
pub enum ClusterContent {
    /// Plain text cluster.
    Text = 0,
    /// Emoji (typically colorful) presentation mode.
    Emoji = 1,
    /// Text presentation mode.
    EmojiText = 2,
    /// Flags generated by a sequence of regional indicators.
    Flag = 3,
}

impl ClusterContent {
    pub fn is_emoji(self) -> bool {
        matches!(self, Self::Emoji | Self::EmojiText)
    }
}

/// The boundary state of a character.
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[repr(u8)]
pub enum Boundary {
    /// A grapheme cluster boundary.
    Cluster = 0,
    /// A word boundary.
    Word = 1,
    /// Both a word boundary and a line break opportunity.
    Line = 2,
}

impl Boundary {
    /// Returns true if this is a grapheme cluster boundary.
    ///
    /// Word and line boundaries are always cluster boundaries.
    pub fn is_cluster(self) -> bool {
        self >= Self::Cluster
    }

    /// Returns true if this is a word boundary.
    ///
    /// Line boundaries are always word boundaries.
    pub fn is_word(self) -> bool {
        self >= Self::Word
    }

    /// Returns true if this is a line break opportunity.
    pub fn is_line_break_opportunity(self) -> bool {
        self == Self::Line
    }
}

/// Analyzer for computing boundary properties.
pub struct BoundaryAnalyzer {
    graphemes: GraphemeClusterSegmenter,
    words: WordSegmenter,
    lines: LineSegmenter,
}

impl BoundaryAnalyzer {
    /// Creates a new boundary analyzer.
    pub fn new() -> Self {
        Self {
            graphemes: GraphemeClusterSegmenter::new(),
            words: WordSegmenter::new_auto(),
            lines: LineSegmenter::new_auto(),
        }
    }

    /// Returns the boundary state for each character in the given text.
    pub fn analyze<'a>(
        &'a self,
        text: &'a str,
    ) -> impl Iterator<Item = Option<(Boundary, ClusterContent)>> + 'a {
        const EMOJI_PRESENTATION: char = '\u{FE0F}';
        const TEXT_PRESENTATION: char = '\u{FE0E}';
        let ext_pict = icu_properties::sets::extended_pictographic();
        let emoji_pres = icu_properties::sets::emoji_presentation();
        let gcb = icu_properties::maps::grapheme_cluster_break();
        let mut graphemes = BoundaryTracker::new(self.graphemes.segment_str(text));
        let mut words = BoundaryTracker::new(self.words.segment_str(text));
        let mut lines = BoundaryTracker::new(self.lines.segment_str(text));
        let mut boundary_and_initial_kind = move |byte_ix, ch| {
            if graphemes.is_boundary(byte_ix) {
                let boundary = if lines.is_boundary(byte_ix) {
                    Boundary::Line
                } else if words.is_boundary(byte_ix) {
                    Boundary::Word
                } else {
                    Boundary::Cluster
                };
                let kind = if emoji_pres.contains(ch) {
                    ClusterContent::Emoji
                } else if ext_pict.contains(ch) {
                    ClusterContent::EmojiText
                } else if gcb.get(ch) == icu_properties::GraphemeClusterBreak::RegionalIndicator {
                    ClusterContent::Flag
                } else {
                    ClusterContent::Text
                };
                Some((boundary, kind))
            } else {
                None
            }
        };
        let mut chars = text.char_indices().chain(Some((text.len(), ' ')));
        let mut last_boundary = Boundary::Line;
        let mut last_kind = ClusterContent::Text;
        let mut last_trailing = 0;
        let mut pending_non_boundaries = 0;
        core::iter::from_fn(move || {
            if pending_non_boundaries > 0 {
                pending_non_boundaries -= 1;
                return Some(None);
            }
            while let Some((byte_ix, ch)) = chars.next() {
                if let Some((boundary, kind)) = boundary_and_initial_kind(byte_ix, ch) {
                    if byte_ix > 0 {
                        let result = (last_boundary, last_kind);
                        last_boundary = boundary;
                        last_kind = kind;
                        pending_non_boundaries = last_trailing;
                        last_trailing = 0;
                        return Some(Some(result));
                    } else {
                        last_boundary = boundary;
                        last_kind = kind;
                    }
                } else {
                    last_trailing += 1;
                    if last_kind.is_emoji() {
                        if ch == EMOJI_PRESENTATION {
                            last_kind = ClusterContent::Emoji;
                        } else if ch == TEXT_PRESENTATION {
                            last_kind = ClusterContent::EmojiText;
                        }
                    }
                }
            }
            None
        })
    }
}

/// Helper for syncing boundary state tracking between
/// multiple iterators.
struct BoundaryTracker<T> {
    iter: T,
    cur_ix: usize,
}

impl<T> BoundaryTracker<T>
where
    T: Iterator<Item = usize>,
{
    fn new(iter: T) -> Self {
        // The first character is always a valid boundary
        Self { iter, cur_ix: 0 }
    }

    /// Is the given byte index a boundary state according to the inner
    /// iterator?
    fn is_boundary(&mut self, ix: usize) -> bool {
        if ix == self.cur_ix {
            true
        } else if ix < self.cur_ix {
            false
        } else {
            while let Some(next_ix) = self.iter.next() {
                if next_ix >= ix {
                    self.cur_ix = next_ix;
                    return next_ix == ix;
                }
            }
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn dump_boundaries() {
        let text =
            "â¤ï¸ a ğŸ‰ rugby  football and an ğŸˆ\u{FE0E} american football ğŸ§™ğŸ¼â€â™€ï¸ â˜º â¤â¤ï¸ à¦¬à¦¿à¦¨à§à¦§à§à¦¯ ğŸ‡«ğŸ‡· \r\n";
        let boundaries = BoundaryAnalyzer::new().analyze(text).collect::<Vec<_>>();
        for (i, ch) in text.chars().enumerate() {
            println!("[{i}] {:?} {ch:?}", boundaries[i]);
        }
    }
}
