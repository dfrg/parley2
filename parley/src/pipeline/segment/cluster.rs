// Copyright 2021 the Parley Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

//! Cluster segmentation with boundary analysis.

use super::super::SpanIndex;
use alloc::vec::Vec;
use core::ops::Range;
use icu_segmenter::{GraphemeClusterSegmenter, LineSegmenter, WordSegmenter};

/// The boundary state of a cluster.
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[repr(u8)]
pub enum BoundaryState {
    /// A word boundary.
    Word = 0,
    /// Both a word boundary and a line break opportunity.
    Line = 1,
}

impl BoundaryState {
    /// Returns true if this represents a word boundary.
    pub fn is_word_boundary(self) -> bool {
        // note: line boundaries are always word boundaries
        self >= Self::Word
    }

    /// Returns true if this represents a line break opportunity.
    pub fn is_line_break_opportunity(self) -> bool {
        self == Self::Line
    }
}

/// The emoji style of a cluster.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
#[repr(u8)]
pub enum EmojiStyle {
    /// Emoji (typically colorful) presentation mode.
    Emoji = 0,
    /// Text presentation mode.
    Text = 1,
    /// Flags generated by a sequence of regional indicators.
    Flag = 2,
}

/// A single grapheme cluster.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct Cluster {
    /// Specifies whether the cluster is a word boundary and/or line
    /// break opportunity.
    pub boundary: Option<BoundaryState>,
    /// If the cluster represents an emoji (or flag), describes the requested
    /// presentation mode.
    pub emoji: Option<EmojiStyle>,
    /// Range (in bytes) of the cluster in the source text.
    pub text_range: Range<usize>,
}

/// Compact steam of clusters.
#[derive(Clone, Default, Debug)]
pub struct ClusterStream {
    overflow_lens: Vec<usize>,
    clusters: Vec<u8>,
}

impl ClusterStream {
    const BOUNDARY_MASK: u8 = 0b11;
    const EMOJI_MASK: u8 = 0b1100;
    const EMOJI_SHIFT: u8 = 2;
    const LENGTH_MASK: u8 = 0xF0;
    const LENGTH_SHIFT: u8 = 4;
    /// We reserve 4 bits for cluster length, using 0xF
    /// to signify overflow
    const MAX_INLINE_LENGTH: usize = 0xF - 1;
}

impl ClusterStream {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn clear(&mut self) {
        self.overflow_lens.clear();
        self.clusters.clear();
    }

    fn push(&mut self, cluster: &Cluster) {
        let len = cluster.text_range.len();
        let boundary = cluster.boundary.map(|x| x as u8 + 1).unwrap_or(0);
        let emoji = cluster.emoji.map(|x| x as u8 + 1).unwrap_or(0);
        let mut state = (boundary & Self::BOUNDARY_MASK) | (emoji << Self::EMOJI_SHIFT);
        if len > Self::MAX_INLINE_LENGTH {
            self.overflow_lens.push(len);
            state |= Self::LENGTH_MASK;
        } else {
            state |= (len as u8) << Self::LENGTH_SHIFT;
        }
        self.clusters.push(state);
    }

    pub fn iter(&self) -> impl Iterator<Item = Cluster> + '_ + Clone {
        let mut overflow_ix = 0;
        let mut start = 0;
        self.clusters.iter().map(move |&state| {
            let boundary = match state & Self::BOUNDARY_MASK {
                1 => Some(BoundaryState::Word),
                2 => Some(BoundaryState::Line),
                _ => None,
            };
            let emoji = match (state & Self::EMOJI_MASK) >> Self::EMOJI_SHIFT {
                1 => Some(EmojiStyle::Emoji),
                2 => Some(EmojiStyle::Text),
                3 => Some(EmojiStyle::Flag),
                _ => None,
            };
            let len_bits = state >> Self::LENGTH_SHIFT;
            let len = if len_bits == 0xF {
                let len = self.overflow_lens[overflow_ix];
                overflow_ix += 1;
                len
            } else {
                len_bits as usize
            };
            let text_range = start..start + len;
            start = text_range.end;
            Cluster {
                boundary,
                emoji,
                text_range,
            }
        })
    }
}

/// Segmenter for splitting text into grapheme clusters with associated
/// boundary and emoji styling properties.
pub struct ClusterSegmenter {
    graphemes: GraphemeClusterSegmenter,
    words: WordSegmenter,
    lines: LineSegmenter,
}

impl Default for ClusterSegmenter {
    fn default() -> Self {
        Self::new()
    }
}

impl ClusterSegmenter {
    /// Creates a new cluster segmenter.
    pub fn new() -> Self {
        Self {
            graphemes: GraphemeClusterSegmenter::new(),
            words: WordSegmenter::new_auto(),
            lines: LineSegmenter::new_auto(),
        }
    }

    /// Returns an iterator over the clusters of the given text.
    pub fn segment<'a>(&'a self, text: &'a str) -> impl Iterator<Item = Cluster> + 'a {
        const EMOJI_PRESENTATION: char = '\u{FE0F}';
        const TEXT_PRESENTATION: char = '\u{FE0E}';
        let ext_pict = icu_properties::sets::extended_pictographic();
        let emoji_pres = icu_properties::sets::emoji_presentation();
        let gcb = icu_properties::maps::grapheme_cluster_break();
        let mut graphemes = BoundaryTracker::new(self.graphemes.segment_str(text));
        let mut words = BoundaryTracker::new(self.words.segment_str(text));
        let mut lines = BoundaryTracker::new(self.lines.segment_str(text));
        let mut chars = text.char_indices();
        let mut last_byte_ix = 0;
        let mut last_boundary = None;
        let mut last_emoji = None;
        core::iter::from_fn(move || {
            while let Some((byte_ix, ch)) = chars.next() {
                // Note that line break opportunities are always word
                // boundaries and word boundaries always fall on the start
                // of a grapheme cluster. So we walk grapheme clusters in
                // the outer "loop" and use the BoundaryTracker type to
                // essentially fast forward the word and line iterators at
                // each grapheme boundary.
                if graphemes.is_boundary(byte_ix) {
                    let mut next_boundary = None;
                    if lines.is_boundary(byte_ix) {
                        next_boundary = Some(BoundaryState::Line);
                    } else if words.is_boundary(byte_ix) {
                        next_boundary = Some(BoundaryState::Word);
                    }
                    let text_range = last_byte_ix..byte_ix;
                    let boundary = last_boundary;
                    let emoji = last_emoji;
                    last_byte_ix = byte_ix;
                    last_boundary = next_boundary;
                    if ext_pict.contains(ch) {
                        // Select the default presentation mode for this emoji
                        // cluster.
                        last_emoji = Some(EmojiStyle::Text);
                        if emoji_pres.contains(ch) {
                            last_emoji = Some(EmojiStyle::Emoji);
                        }
                    } else if gcb.get(ch) == icu_properties::GraphemeClusterBreak::RegionalIndicator
                    {
                        // Track flags as well
                        last_emoji = Some(EmojiStyle::Flag)
                    } else {
                        last_emoji = None;
                    }
                    if text_range.is_empty() {
                        continue;
                    }
                    return Some(Cluster {
                        boundary,
                        emoji,
                        text_range,
                    });
                } else if last_emoji != None {
                    // Explicit presentation mode with variation selectors.
                    if ch == EMOJI_PRESENTATION {
                        last_emoji = Some(EmojiStyle::Emoji);
                    } else if ch == TEXT_PRESENTATION {
                        last_emoji = Some(EmojiStyle::Text);
                    }
                }
            }
            if last_byte_ix < text.len() {
                let text_range = last_byte_ix..text.len();
                last_byte_ix = text.len();
                Some(Cluster {
                    boundary: last_boundary,
                    emoji: last_emoji,
                    text_range,
                })
            } else {
                None
            }
        })
    }

    pub fn segment_compact(&self, text: &str) -> ClusterStream {
        let mut stream = ClusterStream::new();
        self.segment_compact_to(text, &mut stream);
        stream
    }

    pub fn segment_compact_to(&self, text: &str, stream: &mut ClusterStream) {
        stream.clear();
        for cluster in self.segment(text) {
            stream.push(&cluster);
        }
    }
}

/// Helper for syncing boundary state tracking between
/// multiple iterators.
struct BoundaryTracker<T> {
    iter: T,
    cur_ix: usize,
}

impl<T> BoundaryTracker<T>
where
    T: Iterator<Item = usize>,
{
    fn new(iter: T) -> Self {
        // The first character is always a valid boundary
        Self { iter, cur_ix: 0 }
    }

    /// Is the given byte index a boundary state according to the inner
    /// iterator?
    fn is_boundary(&mut self, ix: usize) -> bool {
        if ix == self.cur_ix {
            true
        } else if ix < self.cur_ix {
            false
        } else {
            while let Some(next_ix) = self.iter.next() {
                if next_ix >= ix {
                    self.cur_ix = next_ix;
                    return next_ix == ix;
                }
            }
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn dump_clusters2() {
        let text = "a üèâ rugby  football and an üèà\u{FE0E} american football üßôüèº‚Äç‚ôÄÔ∏è ‚ò∫ ‚ù§‚ù§Ô∏è ‡¶¨‡¶ø‡¶®‡ßç‡¶ß‡ßç‡¶Ø üá´üá∑";
        let clusters = ClusterSegmenter::new().segment(text).collect::<Vec<_>>();
        let segmenter = ClusterSegmenter::new();
        for cluster in segmenter.segment(text) {}
        for cluster in ClusterSegmenter::new().segment(text) {
            let chars = text[cluster.text_range.clone()].chars().collect::<Vec<_>>();
            let ty = match cluster.boundary {
                None => "G",
                Some(BoundaryState::Word) => "W",
                Some(BoundaryState::Line) => "L",
            };
            let emoji = match cluster.emoji {
                None => " ",
                Some(EmojiStyle::Emoji) => "e",
                Some(EmojiStyle::Text) => "t",
                Some(EmojiStyle::Flag) => "f",
            };
            println!("{ty}{emoji} {chars:?} {:?}", cluster.text_range);
        }
    }

    #[test]
    fn compare_compact() {
        let text = "‡¶¨‡¶ø‡¶®‡ßç‡¶ß‡ßç‡¶Ø ‚ù§‚ù§Ô∏è a üßôüèº‚Äç‚ôÄÔ∏è and a üèâ üá´üá∑";
        let segmenter = ClusterSegmenter::new();
        let mut clusters = segmenter.segment(text).collect::<Vec<_>>();
        let stream = segmenter.segment_compact(text);
        let unpacked_clusters = stream.iter().collect::<Vec<_>>();
        for i in 0..clusters.len() {
            let a = &clusters[i];
            let b = &unpacked_clusters[i];
            assert_eq!(a, b);
        }
        println!("blah");
        assert!(clusters.iter().cloned().eq(stream.iter()));
    }
}
